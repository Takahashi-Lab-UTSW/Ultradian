# cross-talk coefficient matrix; analyze data generated by IJ-macro_DV-split-norm.java 

path <- "C:/Users/SHU/Documents/Doc/UltradianCycle/UC-Plots/All_Figs/Figs_B/Fig2/ncfl_20170405CGB-LQBT10m_nonconfl/"	# Set path ############
dt <- 10   # Input, interval=15min ##########################
offs <- 0  # Input offset in Hours ###########################
channel.names <- c("GCaMP","BeRST","TMRM")  # Channel/sensor names #########################
channel.number <- length(channel.names)
clrs<-c("green", "red", "blue", "orange","violet","cyan") # 6 colours
# clrs<-c("orange","red", "green", "violet","cyan")
c<-clrs[1:channel.number]

setwd(path)
library(ggplot2)
library(scales)
library("reshape2")
library(lemon)

scaleFUN <- function(x) sprintf("%.1f", x)  # digits

coef<-read.csv("Coef_matrix_dic1.csv", row.names = 1) # read cross-talk coefficient matrix

# function for cross-talk correction; x: df with sensors as column; coef: cross-talk coefficient matrix
ctc <- function(x, coef){
  y<-c()
  cn<-colnames(x)  # channels
  coef1<-coef[cn,]  # subset coef matrix by channels
  coef2<-coef1[,which(coef1 == 1,arr.in=TRUE)[,2]] # subset coef matrix by channels
  A<-t(coef2) # transpose coef as matrix a to solve
  for (i in 1:nrow(x)){
    b<-matrix(data=x[i,], ncol=1) # matrix b containing raw (non-corrected) data
    c<-solve(A,b)  # corrected values in a matrix
    y<-cbind(y,c)
  }
  y<-t(y)
  colnames(y)<-cn
  return(y)
}

# function to detrend a df by subtracting loess line then add back means of loess fit; span adjustable
detrend <- function(x){
  ## response
  vars <- colnames(x)
  ## covariate
  id <- 1:nrow(x)
  # define a loess filter function (fitting loess regression line) for each column of a df
  loess.filter <- function (y, span) loess(formula = as.formula(paste(y, "id", sep = "~")),
                                           data = data.frame(x),
                                           degree = 1,
                                           span = span)$fitted 
  ## apply loess filter column-by-column
  new.x <- as.data.frame(lapply(vars, loess.filter, span = 0.75), col.names = colnames(x))
  bsl<-matrix(rep(colMeans(new.x),each=nrow(new.x)),nrow=nrow(new.x))
  return(x-new.x+bsl)
}

# read data; 
# files<-list.files(pattern = "R3D.csv$")
# for (f in 1:length(files)){
# image.id<-gsub(".*10m01_(.+)_R3D.*", "\\1", files[f]) # extract image number by substring
# df<-read.csv(files[f])

df<-read.csv("20170405CGB-LQBT10m01_39_R3D.csv")  ###############################################################################

df<-df[ , colSums(is.na(df)) == 0]  # remove columns containing NA
Hours <- (1:nrow(df)-1)/(60/dt)+offs				# offset hours after Shock

cell.n<-ncol(df)/channel.number # cell number

  dft<-df[,grepl("T",colnames(df))]
  # dfc<-ctc(dft,coef)  # cross-talk correction
  dfn<-sweep(dft, 2, colMeans(dft), FUN="/") #normalize to mean of each column
  dat0<-cbind(Hours,dfn)
  colnames(dat0)<-c("Hours", paste("Cell", 1:cell.n, sep="_"))
  dat1 <- melt(data.frame(dat0), id.vars="Hours", variable.name="Cell", value.name="Fluorescence")
  dat1<-data.frame(dat1)
  
  # labels for each facets
  len <- length(levels(dat1$Cell))
  vars <- data.frame(expand.grid(levels(dat1$Cell)))
  colnames(vars) <- c("Cell")
  fct_labs<-data.frame(x=0, y=apply(dat0[,-1],2,max)+0.05, vars, lbl=paste("Cell",1:cell.n, sep="_"))
  scaleFUN <- function(x) sprintf("%.1f", x)  # digits

  # p + facet_rep_grid(drv ~ cyl) + coord_capped_cart(bottom='both', left='both') +
  #   theme_bw() + theme(panel.border=element_blank(), axis.line=element_line())
  
  plotname<-"p_NCFL_TMRM"
  
  p <- ggplot(data=dat1, aes(x=Hours, y=Fluorescence, group=Cell)) + 
    geom_line(linetype=1, size=0.1, colour= "blue" )+  
    # scale_colour_identity() + 
    facet_rep_grid(Cell~., scales="free")+
    # facet_wrap(~Cell, ncol=1,  scales="free")+
    coord_capped_cart(bottom='both', left='both')+
    
    geom_text(aes(x,y,label=lbl, group=NULL), data=fct_labs,  parse = TRUE, hjust=0.1, vjust=2, size=1.5)+ 
    # geom_text size = 1 (mm) = 1/0.35 points
    
    scale_y_continuous(breaks=pretty_breaks(n = 3), labels=scaleFUN)+ # set y-axis labels
    
    ylab("TMRM Fluorescence") +
    xlab("Hours") + 
    theme_classic() +       # Removes gridlines & background
    theme(axis.title.y = element_text(face = "plain", color = "black", size = 6), # theme text size in pt
          axis.title.x = element_text(face = "plain", color = "black", size = 6), 
          axis.text.y = element_text(face = "plain", color = "black", size = 4), 
          axis.text.x = element_text(face = "plain", color = "black", size = 6, vjust=0), 
          axis.line = element_line(size=0.1),
          axis.ticks = element_line(colour = "black", size = 0.1),
          axis.ticks.length = unit(1, "pt"),
          # panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          panel.border = element_blank(),
          panel.spacing.y=unit(0.2, "line"),
          # # plot.margin = margin(1, 1, 1, 1, "pt"),
          # legend.position = c(0.8,0.9),
          legend.position = "none",
          # legend.title = element_blank(),
          # legend.background = element_blank(),
          # legend.text = element_text(size=3),
          # legend.key.height = unit(0.01,"line"),
          # legend.key.width = unit(0.2, "line"),
          # legend.spacing.x = unit(0.2, "line"),
          # # legend.spacing.y = unit(0.005, "line")
          plot.margin = margin(8,12,8,12,"pt"),
          strip.background = element_blank(),
          strip.text = element_blank()
    )+
  scale_x_continuous(breaks = seq(0,120,24))
  # scale_color_manual(values=c("red"))
  
  assign(plotname,p)
  
  # output pdf
  ggsave(filename=paste(plotname,"pdf",sep="."), plot=get(plotname), useDingbats=F, width=2, height=2)
  
  



