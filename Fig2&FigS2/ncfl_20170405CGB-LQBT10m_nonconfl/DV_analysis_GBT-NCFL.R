# cross-talk coefficient matrix; analyze data generated by IJ-macro_DV-split-norm.java 

path <- "C:/Users/SHU/Documents/Doc/UltradianCycle/UC-Plots/All_Figs/Fig4/ncfl_20170405CGB-LQBT10m_nonconfl/"	# Set path ############
dt <- 10   # Input, interval=15min ##########################
offs <- 0  # Input offset in Hours ###########################
channel.names <- c("GCaMP","BeRST","TMRM")  # Channel/sensor names #########################
channel.number <- length(channel.names)
clrs<-c("green", "red", "blue", "orange","violet","cyan") # 6 colours
# clrs<-c("orange","red", "green", "violet","cyan")
c<-clrs[1:channel.number]

setwd(path)
library(ggplot2)
library(scales)
library("reshape2")
scaleFUN <- function(x) sprintf("%.1f", x)  # digits

coef<-read.csv("Coef_matrix_dic1.csv", row.names = 1) # read cross-talk coefficient matrix

# function for cross-talk correction; x: df with sensors as column; coef: cross-talk coefficient matrix
ctc <- function(x, coef){
  y<-c()
  cn<-colnames(x)  # channels
  coef1<-coef[cn,]  # subset coef matrix by channels
  coef2<-coef1[,which(coef1 == 1,arr.in=TRUE)[,2]] # subset coef matrix by channels
  A<-t(coef2) # transpose coef as matrix a to solve
  for (i in 1:nrow(x)){
    b<-matrix(data=x[i,], ncol=1) # matrix b containing raw (non-corrected) data
    c<-solve(A,b)  # corrected values in a matrix
    y<-cbind(y,c)
  }
  y<-t(y)
  colnames(y)<-cn
  return(y)
}

# function to detrend a df by subtracting loess line then add back means of loess fit; span adjustable
detrend <- function(x){
  ## response
  vars <- colnames(x)
  ## covariate
  id <- 1:nrow(x)
  # define a loess filter function (fitting loess regression line) for each column of a df
  loess.filter <- function (y, span) loess(formula = as.formula(paste(y, "id", sep = "~")),
                                           data = data.frame(x),
                                           degree = 1,
                                           span = span)$fitted 
  ## apply loess filter column-by-column
  new.x <- as.data.frame(lapply(vars, loess.filter, span = 0.75), col.names = colnames(x))
  bsl<-matrix(rep(colMeans(new.x),each=nrow(new.x)),nrow=nrow(new.x))
  return(x-new.x+bsl)
}

# read data; 
files<-list.files(pattern = "R3D.csv$")

for (f in 1:length(files)){
  
image.id<-gsub(".*10m01_(.+)_R3D.*", "\\1", files[f]) # extract image number by substring

df<-read.csv(files[f])
df<-df[ , colSums(is.na(df)) == 0]  # remove columns containing NA
Hours <- (1:nrow(df)-1)/(60/dt)+offs				# offset hours after Shock

cell.n<-ncol(df)/channel.number # cell number

for (i in 1:cell.n){
  dfi<-df[,c(i,i+cell.n,i+2*cell.n)]
  colnames(dfi)<-channel.names
  # dfc<-ctc(dfi,coef)  # cross-talk correction
  dfn<-sweep(dfi, 2, colMeans(dfi), FUN="/") #normalize to mean of each column
  dat0<-cbind(Hours,dfn)
  colnames(dat0)<-c("Hours", channel.names)
  dat1 <- melt(data.frame(dat0), id.vars="Hours", variable.name="Sensor", value.name="Fluorescence")
  
  plotname<-paste("p_GBT_image",image.id,"_cell",i,sep="")   ###########################################################################
  
  p <- ggplot(data=dat1, aes(x=Hours, y=Fluorescence, group = Sensor)) +  
    geom_line(linetype=1, aes(color=Sensor), size=0.1)+
    ylab("Fluorescence") +
    xlab("Hours") + 
    theme_classic() +       # Removes gridlines & background
    theme(axis.title = element_text(face = "plain", color = "black", size = 8), 
          axis.text = element_text(face = "plain", color = "black", size = 8), 
          axis.line = element_blank(),
          axis.ticks = element_line(colour = "black", size = 0.1),
          axis.ticks.length = unit(1.5, "pt"),
          panel.border = element_rect(colour = "black", fill=NA, size=0.1),
          # plot.margin = margin(1, 1, 1, 1, "pt"),
          legend.position = c(0.2,0.85),
          legend.title = element_blank(),
          legend.background = element_blank(),
          legend.text = element_text(size=6),
          legend.key.height = unit(0.01,"line"),
          legend.key.width = unit(0.2, "line"),
          legend.spacing.x = unit(0.2, "line"),
          # legend.spacing.y = unit(0.005, "line")
    )+
    scale_color_manual(values=c)+
    scale_x_continuous(breaks=seq(0,240,24))+
    scale_y_continuous(expand=c(0.1,0.1), breaks=pretty_breaks(n = 4), labels=scaleFUN) # set y-axis labels
  
  # # Add text on a specific positions:
  # p + annotate("text", x = c(2,4.5), y = c(20,25), label = c("label 1", "label 2") , color="orange", size=5 , angle=45, fontface="bold")
  # # Add rectangles
  # p + annotate("rect", xmin=c(2,4), xmax=c(3,5), ymin=c(20,10) , ymax=c(30,20), alpha=0.2, color="blue", fill="blue")
  # # Add segments
  # p + annotate("segment", x = 1, xend = 3, y = 25, yend = 15, colour = "purple", size=3, alpha=0.6)
  # # Add arrow
  # p + annotate("segment", x = 2, xend = 4, y = 15, yend = 25, colour = "pink", size=3, alpha=0.6, arrow=arrow())
  

  assign(plotname,p)
  
  # output pdf
  ggsave(filename=paste(plotname,"pdf",sep="."), plot=get(plotname), useDingbats=F, width=2, height=1.5) 
  
}


  
}



